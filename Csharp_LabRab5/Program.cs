using System;

/*
  ЗАДАНИЯ:
1.	Реализовать структуру Point для хранения координат X и Y с функцией вывода этих значений на консоль.
2.	Реализовать стек с операциями записи значения в стек и извлечения значения из стека.
3.	Создать класс в интересной вам предметной области. Класс должен иметь несколько полей с разными типами, в том числе nullable types и enums. Определить конструктор по-умоланию и несколько свойств. Определить индексатор.
4.	Что нужно сделать, чтобы с классом можно было работать с помощью цикла foreach.
5.	Реализовать структуру (иерархию) классов (от 3 штук) в интересной вам предметной области, используя наследование, полиморфизм. Задействуйте интерфейсы, абстрактные классы, абстрактные и виртуальные функции. 
    Напишите программу для демонстрации вызова виртуальных функций у объектов различных классов из вашей иерархии.
*/

namespace Csharp_LabRab5{
    struct Point
    {
        public int x_coord, y_coord;           //координаты точек x и y
        
        public void info() {
            Console.WriteLine($"x = {x_coord}, y = {y_coord}.");    
            //обращаем внимание на то, что при использовании в индексируемых местозаполнителях полей структуры, перед фиксированным текстом необходимо поставить символ "$".
        }
    }                         //структура для задания 1
    
    public class MyStack<T> {               //класс стека. <T> указывает на то, что клсс является обобщенным, и T далее будет использоваться как тип данных при работе с данными
        private T[] elements;               //объявление массива типа T, сюда будут складываться элементы стека
        private int count;                  //указатель на элемент массива

        public MyStack() {                  //конструкор класса
            elements = new T[1];            //инициаллизация массива элементов
            count = 0;                      //инициализация счетчика
        }

        public void push(T element) {       //метод помещения нового элемента в массив
            elements[count] = element;      //помещаем новый элемент в массив с текущим указателем на индекс 
            Console.WriteLine("В стек помещен элемент {0}, его № {1}.", elements[count], count);
            count++;                        //инкрементируем указатель на элемент массива
            Array.Resize(ref elements, elements.Length + 1);    //т.к. Array не является динамическим, то используем метод Resize для задания новой границы массива
        }
        
        public string pull() {              //метод извлечения нового элемента в массив, будем конвертировать в строку
            string result;
            count--;                        //декрементируем указатель на элемент массива
            result = ("Извлекается элемент стека "+Convert.ToString(elements[count])+", его № "+(count)+".");
            Array.Resize(ref elements, elements.Length - 1);    //уменьшаем размер массива
            return result;
        }

        public void showMyStack() {         //метод вывода элементов стека в консоль
            for (int i = 0; i < count; i++)
                Console.WriteLine("Элемент стека №{0} - {1}", i, elements[i]);
        }
    }             //класс для задания 2

    public enum Country {                   //перечисление стран
        Russia = 1,
        USA,
        EU
    };    

    public abstract class FinInstrument {   //абстрактный класс для задания 3
        //СТРУКТУРА ДАННЫХ
        enum Currency { RUB = 1, USD, EUR };    //перечисление валют, в которых торгуется финансовый инструмент
        decimal? current_price, lowest_price, highest_price; //"?" после типа значения указывает на то, что поле содержит значение null. Эквивалентно System.Nullable<T>, где T - тип значения
        string ticker;      //тикер             //напр. GOOG
        string name;        //имя инструмента   //напр. Alphabet inc. class C
        string issuer;      //эмитент           //напр. Alphabet inc.
        Currency nati_curr; //в какой нацвалюте торгуется инструмент
        Country country;    //страна-эмитент

        /*Свойство — это член, предоставляющий гибкий механизм для чтения, записи или вычисления значения частного поля. Свойства можно использовать, как если бы они были членами общих данных, но фактически они представляют 
        собой специальные методы, называемые методами доступа. Это позволяет легко получать доступ к данным и помогает повысить безопасность и гибкость методов.*/
        string issuer_country { get; set; }     //страна эмитента; автоматическое реализуемое свойство с методами доступа get и set
        public string Issuer                    //еще одна реализация свойства c методами доступа get и set
        {
            get => issuer;                      //получаем имя эмитента по обращению *имя объекта*.Issuer
            set => issuer = value;              //пишем значение так же: *имя объекта*.Issuer = *значение*
        }

        /*Индексаторы позволяют индексировать объекты и обращаться к данным по индексу. Фактически с помощью индексаторов мы можем работать с объектами как с массивами. 
        По форме они напоминают свойства со стандартными блоками get и set, которые возвращают и присваивают значение.

        Формальное определение индекатора:

        возвращаемый_тип this [Тип параметр1, ...]
        {
            get { ... }
            set { ... }
        }*/

        //КОНСТРУКТОРЫ
        public FinInstrument() {    //переопределение конструктора по умолчанию - будут устанавливаться значения перечислений по умолчанию
            nati_curr = Currency.USD;
            country = Country.USA;
        }

        public FinInstrument(Country country, string issuer, string ticker) {   //параметрический конструктор

            switch (country) {      //в зависимости от инкапсулируемого значение enum Country задается значение enum Currency, входящее в класс FinInstrument
                case Country.Russia:
                    nati_curr = Currency.RUB;
                    break;
                case Country.USA:
                    nati_curr = Currency.USD;
                    break;
                case Country.EU:
                    nati_curr = Currency.EUR;
                    break;
            }
            this.issuer = issuer;       //через this инкапсулируется значение поля именно данного экземпляра объекта, который создается настоящим конструктором
            this.ticker = ticker;       //такой способ можно использовать для самописных методов доступа get и set. здесь же стоит упомянуть, что через super. можно получить доступ к значению поля не объекта, а суперкласса
        }

        //МЕТОДЫ

    }

    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                Console.WriteLine("***ЗАДАНИЕ 1***\n");
                Point p = new Point();                          //создаем новую структуру
                p.x_coord = 2;                                  //указывае значение координаты х
                p.y_coord = 3;                                  //указывае значение координаты y
                p.info();                                       //выводим информацию о координатах

                Console.WriteLine("\n***ЗАДАНИЕ 2***\n");
                //первая реализация обобщенного класса стека - целочисленная
                MyStack<int> Mstack = new MyStack<int>();       //создаем новый стек, задаем тип <int>
                Mstack.push(p.x_coord);                         //занесем в него координаты из реализованной структуры
                Mstack.push(p.y_coord);
                Mstack.showMyStack();                           //выведем элементы стека на экран
                Console.WriteLine(Mstack.pull());               //и достанем элементы из стека
                Console.WriteLine(Mstack.pull());               //и еще раз

                //еще одна реализация обобщенного класса стека - булевая
                bool b1 = true;                                 //для чистоты эксперимента объявим и инициализируем булевую переменную b1 с значением true
                MyStack<bool> boolStack= new MyStack<bool>();   //создаем новый стек, задаем тип <bool>
                boolStack.push(b1);                             //заносим в него первую переменную b1
                boolStack.push((p.x_coord>p.y_coord));          //и результат проверки условия 
                boolStack.showMyStack();                        //распечатаем и посмотрим, что будет хранить стек

            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
            finally {
                Console.WriteLine("\n<Press any button...>");
                Console.ReadKey();
            }
        }
    }
}